
## 💡 기존 퀘스트에 대한 의견
### 📌 퀘스트 1번

- 기존 퀘스트 1번의 경우, `복잡한 메서드`에 대해 사람이 생각하기 어려운 테스트 시나리오를 도출해 달라고 AI에게 요청하는 방식인데, 이것은 자칫 테스트를 하면서 중요한 개념에 대해 학습하거나 생각을 떠올려 볼 기회를 놓칠 수 있는 문제점이 있다.
- **어떻게 개선해 볼 수 있을까?**
    - 키워드를 추천 받고 테스트코드 같이 반복적으로 작성해야 하는 부분을 작성해돌라
	- `복잡한 메소드 대상 AI 기반 유닛 테스트 시나리오 도출` 부분을 조금 더 발전시켜보면? 
	  어떤 하나의 기능에 대해, AI와 함께 테스트 커버리지를 100% 달성하기 위해 어떤 테스트 항목이 필요할 지 논의해 볼 수도 있지 않을까?

### 📌 퀘스트 2번

- CS지식과 관련해 AI에게 퀴즈를 받고 답변해보면서, 채점과 해설을 받아보며, 필요하면 오답노트까지 작성해보는 일련의 활동이 좋았다고 생각이 된다.
- 퀴즈를 받고 관련한 CS 지식에 대해 다시 한번 복기해보기에 좋은 방식이라고 생각된다.
- 퀴즈를 풀어보고 나의 언어로 정리해 보는 것도 좋지 않을까? 그리고 `나의 언어`로 정리한 내용이 다른 사람들도 이해할 수 있도록 쉽고, 잘 구조적으로 정리되었는지 AI에게 피드백을 받아보는 방식은 어떨까?

### 📌 퀘스트 3번

- 기존 음성 녹음이나 회의 기록 등을 클로바와 같은 AI 도구를 통해 대화 내용을 요약하는 방법으로는 서로의 상황을 이해하고 공감하기에 부족한 부분이 있다고 생각된다.
- - **어떻게 개선해 볼 수 있을까?**
	- 클로바를 통해 얻은 내용으로 AI한테 컨디션 체크 받기
    - 피어 피드백 회의 내용이나, 내가 녹음한 것 등등, 대화 내용을 AI로 요약하거나 분석해 대화를 나누는 동료와 나의 컨디션을 체크해 볼 수 있지 않을까?
    

### 📌 퀘스트 4번

- 처음에는 굉장히 신선했으나, 릴레이 프로젝트가 진행되면서 자주 보이는 AI 활용 방식이라 현재는 다소 무난하게 생각이 되는 주제라고 생각된다.

## 🔍 관련 정보 조사하기

### 📌 설계한 것에 대해 다이어그램 그려보기

- 학습과 구현을 하기 위한 시간이 부족하다. 
- 또한, README 등을 작성할 떄 구조를 잘 표현하기 위해 다이어그램을 활용하는 경우가 많다.
- 시간을 절약하고, 편리하게 내가 설계한 구조를 그림으로 나타내기 위해 AI를 활용해보자.
- 방법
    - AI한테 구현 코드를 주고 흐름도 또는 클래스 다이어그램 **Mermaid형식으로 변환**
        - **GitHub(자동 렌더링, .md), mermaidChart 으로 렌더링**
    - AI한테 구현 코드를 주고 PlantUML로 변환 시키고 PlantText에서 도식화

### 📌 퀴즈를 AI와 재미있게 풀어보기

- 팀원 간 같이 참여할 수 있는 퀘스트가 부족했고 퀴즈만 단순하게 풀기에는 흥미가 떨어지는 부분이 있기 때문에, 더 흥미를 유발할 수 있는 방향으로 AI와의 퀴즈를 활용할 수 있는 방법을 조사해 보았다.

### 📌 오늘의 나의 AI 활용법

- AI를 다양하게 활용하면서 미션을 진행하는데, 자신만의 AI 응용법이 있지 않을까? 서로 커뮤니티에서 좋은 AI 활용법을 공유할 수 있는 기회가 되었으면 좋을 것 같다라는 의견.

### 📌 피어 세션

- AI 피어세션을 둘러보면서, AI를 다른 사람들이 활용한 방법을 둘러보았다.
- 나 자신이 생각하지 못했던 새로운 방식이나 자신이 생각하기에 정말 활용하기 좋을 것 같은, 성장과 학습에 도움이 될 것 같은 방식으로 사용한 사례를 찾아 보는 것도 좋을 것 같다.

## 📝 퀘스트 목록

### 1. 설계를 AI로 시각화하기

**배경**
- README 등을 작성할 떄 구조를 잘 표현하기 위해 다이어그램을 활용하는 경우가 많은데 그것을 그리기 위해 시간을 투자해야한다
- 지난주 미션에서 설계를 README.md에 추가하고 구현을 진행하라는 미션이 있었는데, 설계를 직접 손으로 그려서 첨부하니 깔끔하게 표현이 힘들다

**목적**
- 다이어그램 그리는 시간을 줄여 학습 및 구현할 시간을 확보하자

**진행 방법**
- 택1) 내가 설계한 내용을 AI 주어 Mermaid파일로 변환하여 렌더링
- 택2) AI한테 구현한 코드들을 주고 흐름도 또는 클래스 다이어그램 Mermaid형식으로 변환 후 렌더링

**도구**
- GitHub(자동 렌더링, .md), mermaidChart 으로 렌더링
- PlantUML로 변환 시키고 PlantText에서 도식화

### 2. CS 지식과 관련된 퀴즈를 AI를 사용해 팀원들과 재미있게 풀어보기

**배경 및 목적**
- 릴레이 프로젝트에서 팀원과 같이 할 수 있는 부분이 없었음. ( 같이 하면 재미 있었던 기억 )
- 게임같이 레벨과 같은 보상이 있을 경우 좀 더 재미있게 할 수 있지 않을까? 라는 생각.

**진행 방법**
1. 팀원 중 퀴즈 퀘스트를 같이 할 사람을 찾는다.
2. 문제를 생성하는 프롬포트 ( 문제의 점수도 추가로 요청합니다. 최대 5점 )
3. 매일 or 정해진 날짜마다 문제를 각자 분야에 맞게 문제를 생성해 공유하고 문제를 푼다.
4. 마지막 릴레이 프로젝트 날에 정리 혹은 slack 에 공유해본다.

**퀘스트 예시 - RPG 답게 만들 수 있는 방법**

- 캐릭터 & 클래스 시스템

```markdown
각 팀원이 "전문 분야"선택

- 알고리즘 마법사 (알고리즘 문제 +보너스점)
- 네트워크 전사 (네트워크 문제 +보너스점)
- 데이터 베이스 사제 (SQL 문제 +보너스점)
- 시스템 도적 (설계 문제 +보너스점)
```

- 협력 퀘스트
- 릴레이: 문제 A가 문제 1단계를 풀면 B가 2단계, C가 3단계
- 미션 : 각자 다른 분야 문제를 풀어서 종합 점수로 평가

```markdown
레벨업 시스템
- lv 1~5 새내기 개발자
- lv 6~10 주니어 개발자
- lv 11~15 시니어 개발자
- lv 16+ 태크 리드 개발자
```
    
**진행 방법**
    
- 주 2회나 매일 1번 등은 자유!

### 3. AI 피어 세션 추천하기

**배경**
- AI 피어세션을 통해서 동료들이 어떻게 AI를 사용하는지 다양한 방법을 확인할 수 있었음
- 새로운 AI 활용 방법을 직접 적용해보기 위해서 동료의 AI 활용 방법을 직접 정리해보면 좋을거같음

**미션**
- 동료의 AI 피어세션 & AI 활용 방법 추천하기

**진행 방법**
1. 동료들의 AI 피어 세션을 구경한다.
2. 내가 생각하지 못했던 방식으로 AI를 사용한 동료의 AI 활용 방식을 정리한다.
3. 어떤 동료의 AI 피어세션을 참고했는지 추가해 정리한 내용을 슬랙에 공유한다.

### 4. 오늘의 나의 AI 활용법 중 괜찮았던 부분을 Slack에 공유하기

**배경**
- 그동안은 AI를 단순히 실용적인 도구로만 활용해왔는데, 이번에는 그 경험을 이론적인 관점에서도 정리해서 공유해보고 싶음.

**진행 방법**
- 어떤 상황에서 사용했는지?
- 어떻게 활용했는지?
- 왜 이렇게 활용했는지?
- 어떤 결과가 나왔는가?
- 어떻게 다른 분들이 활용하면 좋겠는지

	slack에 많은 사람들이 서로 알 수 있게끔 `random` 채널 등에 공유하기
	
- 댓글로, 더 좋은 활용 방향이 있으면 추천 받기

---

# 퀘스트 수행 결과

---

`J014_강지호`<br>
수행할 퀘스트 : 퀘스트 2!!
<br>
선정 이유 : 미션과 관련된 CS지식을 AI와의 퀴즈를 통해 학습하면 재미있을 것 같았다.

<details>
<summary> 수행 과정 </summary>
# 📘 TCP 클라이언트/서버 구현 관련 네트워킹 CS 퀴즈

이번 TCP 기반 미션을 통해 학습할 수 있는 네트워크 및 CS 지식 퀴즈입니다.  
OX / 객관식 / 단답형 / 응용 단답형으로 구성되어 있습니다.

---

## 1. ✅ OX 문제  
**TCP는 클라이언트가 연결을 종료하면 서버의 `socket.on('end')` 이벤트가 발생한다.**

⬜ O  
⬜ X

---

## 2. ✅ 객관식  
**TCP의 연결 확립 3-way handshake에 포함되지 않는 단계는?**

A. SYN  
B. SYN-ACK  
C. ACK  
D. FIN

---

## 3. ✅ 단답형  
**서버에서 하나의 클라이언트만 특정 역할(예: MD)로 제한하려면, 어떤 구조로 관리하면 좋을까?**  
(키워드만 써도 OK)

---

## 4. ✅ 객관식  
**TCP와 UDP를 비교할 때 맞는 설명은?**

A. UDP는 흐름 제어를 제공한다.  
B. TCP는 순서 보장을 하지 않는다.  
C. UDP는 연결지향적이다.  
D. TCP는 패킷 유실 시 재전송을 한다.

---

## 5. ✅ OX 문제  
**서버에서 연결된 클라이언트들을 모두 추적하려면 Set 또는 Map 자료구조가 적절하다.**

⬜ O  
⬜ X

---

## 6. ✅ 단답형  
**TCP 소켓에서 데이터를 읽을 때 발생하는 이벤트 이름은?**

---

## 7. ✅ 객관식  
**다음 중 `client.write(...)`를 하면 실제로 일어나는 동작은?**

A. 파일을 씀  
B. 클라이언트가 종료됨  
C. 서버로 메시지를 전송함  
D. 소켓 연결을 닫음

---

## 8. ✅ 단답형  
**TCP 서버가 여러 명의 클라이언트를 동시에 처리할 수 있는 이유는?**  
(힌트: `socket.on('data')`가 각 클라이언트마다 독립적으로 동작하는 구조)

---

## 9. ✅ OX 문제  
**TCP 통신에서는 메시지가 JSON으로 온전히 오지 않거나 잘리는 경우도 발생할 수 있다. 이를 방지하려면 메시지 구분자가 필요하다.**  
(ex: `\n` 기준으로 split)

⬜ O  
⬜ X

---

## 10. ✅ 응용 단답형  
**서버가 클라이언트의 종류(캠퍼 vs MD)를 구분하려면 클라이언트 소켓에 어떤 속성을 설정해두는 방식이 유용한가?**


# 📘 TCP Client/Server 미션 관련 네트워킹 CS 퀴즈 및 해설

지호님의 TCP 클라이언트/서버 기반 미션과 관련된 네트워킹 및 CS 개념들을 바탕으로 만든 퀴즈와 해설입니다.

---

## ✅ 퀴즈 및 해설

### 1. OX 문제  
**Q.** TCP는 클라이언트가 연결을 종료하면 서버의 `socket.on('end')` 이벤트가 발생한다.  
✅ **정답: O**  
**해설:** TCP에서는 클라이언트가 `end()` 또는 `destroy()`로 연결을 종료하면, 서버 측에서는 `socket.on('end')` 이벤트가 발생해서 종료 처리를 할 수 있음.

---

### 2. 객관식  
**Q.** TCP의 연결 확립 3-way handshake에 포함되지 않는 단계는?  
✅ **정답: D. FIN**  
**해설:** TCP 연결 확립은 **SYN → SYN-ACK → ACK**의 3단계. FIN은 연결 종료 과정에서 사용됨.

---

### 3. 단답형  
**Q.** 서버에서 하나의 클라이언트만 특정 역할(예: MD)로 제한하려면?  
✅ **정답 예시:** `mdSocket`, `전용 socket 변수`, `플래그`, `role 속성`  
**해설:** MD를 식별하기 위해 전역 변수(`mdSocket`)나, 각 socket에 `.isMD = true` 같은 속성을 붙여 관리하는 방식이 일반적임.

---

### 4. 객관식  
**Q.** TCP와 UDP를 비교할 때 맞는 설명은?  
✅ **정답: D. TCP는 패킷 유실 시 재전송을 한다**  
**해설:**  
- A: UDP는 흐름 제어 없음 ❌  
- B: TCP는 순서 보장함 ❌  
- C: UDP는 비연결형 프로토콜 ❌  
- D: TCP는 신뢰성 보장 위해 재전송 O ✅

---

### 5. OX 문제  
**Q.** 서버에서 연결된 클라이언트들을 모두 추적하려면 Set 또는 Map 자료구조가 적절하다.  
✅ **정답: O**  
**해설:** `Set<Socket>`이나 `Map<campId, Socket>`을 사용하면 여러 클라이언트를 효율적으로 관리할 수 있음.

---

### 6. 단답형  
**Q.** TCP 소켓에서 데이터를 읽을 때 발생하는 이벤트 이름은?  
✅ **정답: `data`**  
**해설:** `socket.on('data', callback)`은 TCP에서 수신된 데이터를 처리할 때 사용하는 이벤트임.

---

### 7. 객관식  
**Q.** `client.write(...)`를 하면 실제로 일어나는 동작은?  
✅ **정답: C. 서버로 메시지를 전송함**  
**해설:** `write`는 TCP 소켓을 통해 데이터를 전송하는 명령. Node.js에서는 문자열이나 버퍼를 보낼 수 있음.

---

### 8. 단답형  
**Q.** TCP 서버가 여러 명의 클라이언트를 동시에 처리할 수 있는 이유는?  
✅ **정답 예시:** 각 클라이언트마다 별도 socket 인스턴스 생성, 비동기 이벤트 기반 처리  
**해설:** Node.js는 이벤트 기반으로 작동하므로, 연결될 때마다 독립적인 `socket` 객체가 생성되어 병렬 처리처럼 작동함.

---

### 9. OX 문제  
**Q.** TCP 통신에서는 메시지가 JSON으로 온전히 오지 않거나 잘리는 경우도 발생할 수 있다. 이를 방지하려면 메시지 구분자가 필요하다.  
✅ **정답: O**  
**해설:** TCP는 스트림 기반이므로 메시지가 중간에 끊겨서 들어올 수도 있다. 그래서 `\n` 같은 구분자를 넣고 `.split('\\n')`으로 처리해야 안정적임.

---

### 10. 응용 단답형  
**Q.** 서버가 클라이언트의 종류(캠퍼 vs MD)를 구분하려면 클라이언트 소켓에 어떤 속성을 설정해두는 방식이 유용한가?  
✅ **정답 예시:** `socket.isMD = true`, `socket.role = 'camper' | 'md'`, 별도 Map으로 역할 추적  
**해설:** Node.js의 `socket` 객체는 속성을 자유롭게 붙일 수 있으므로,
**결과**

## 느낀점
- 확실히 AI가 객관식, 단답형, 주관식 등 다양한 형태로 CS 지식 문제를 내줘서 몰랐던 부분이나 헷갈릴 만한 부분을 잘 학습할 수 있었다.

</details>

---

`J060_김윤영`<br>
수행할 퀘스트 : 1\.설계를 AI로 시각화하기
<br>
선정 이유 : 미션을 진행하면서 도움을 받을 수 있는 퀘스트이기에 선택했다.

<details>
<summary> 수행 과정 </summary>
Day16. 벡터DB 만들기 미션에서 진행하였다. <br>
1. 보다 완성도 높은 다이어그램을 위해 최대한 자세히 설계한다.
2. 생성할 다이어그램을 선택한다. (클래스 다이어그램으로 선정했다.)
3. 설계한 내용을 AI에게 mermaid로 다이어그램 코드를 생성한다.

</details>

-   `<details>` 태그 안에서 코드 블럭을 인식하지 않아 밖으로 빼 두었다.

    ```mermaid
    classDiagram
        class CLI {
            - VectorDBMS vectorDBMS
            - Logger logger
            - readline.Interface rl
            + async init()
            + parseInput(input)
            + validateCommand(command)
            + async run()
        }

        class VectorDBMS {
            - VectorDB vectorDB
            - TransformersEmbedder embedder
            + async init()
            + async add(id)
            + async remove(id)
            + cosineSimilarity(a, b)
            + async searchByKNN(text, k)
        }

        class VectorDB {
            - string filePath
            - string|null dimension
            - Map~string, number[]~ data
            - VectorDBValidator validator
            + async isFileExists()
            + async init(dimension)
            + async save()
            + async load()
            + async add(id, vector)
            + async remove(id)
            + getVector(id)
            + getData()
        }

        class Logger {
            + logHeader()
            + logAdd(id, duration)
            + logRemove(id, duration)
            + logSearchByKNN(array, duration)
        }

        class TransformersEmbedder {
            - string modelName
            - object|null embedder
            + async initialize()
            + async embed(text)
            + getDimension()
        }

        class VectorDBValidator {
            + validateDimension(vector, dimension)
            + validateIDExists(id, map)
            + validateIDNotExists(id, map)
            + validateJsonStructure(json, dimension)
        }

        CLI --> VectorDBMS : has
        CLI --> Logger : has
        VectorDBMS --> VectorDB : has
        VectorDBMS --> TransformersEmbedder : has
        VectorDB --> VectorDBValidator : has

    ```

---

`J175_윤효준`<br>
수행할 퀘스트 : 퀘스트를 입력해주세요!
<br>
선정 이유 : 이유를 입력해주세요!

<details>
<summary> 수행 과정 </summary>


 
</details>

---

`K022_장무호`<br>
수행할 퀘스트 : 2\. CS 지식과 관련된 퀴즈를 AI를 사용해 팀원들과 재미있게 풀어보기
<br>
선정 이유 : 전문 분야를 골라 학습하고, RPG 형식으로 수행할 수 있는 점이 인상깊게 다가왔습니다! 저는 설계가 약하기 때문에 시스템 도적으로 캐릭터 하나 파겠습니다😁

<details>
<summary> 수행 과정 </summary>

---
저도 지호님처럼 크게 서술을 요하지 않는 가벼운 문제 10개를 세 분야로부터 가져와서 풀어보기로 하였습니다.

<img width="842" height="547" alt="스크린샷 2025-08-08 173739" src="https://github.com/user-attachments/assets/d1b382f2-d656-4089-9bfd-4fcb54751406" />
사진처럼 직업을 밝히고 어떤 유형과 난이도의 문제를 n개 제출해달라고 설정하니,<br>
그에 맞춰서 어떤 문제를 출제할 것이라는 것을 먼저 밝히고 시작했습니다.<br>

---

🔮 알고리즘 마법사 영역
1. OX 문제
Q1. 정렬된 배열에서 이진 탐색의 시간 복잡도는 O(n)이다.
→ O / X

---

2. 객관식 문제
Q2. 다음 중 시간 복잡도가 가장 느린 알고리즘은?
A. O(n)
B. O(n log n)
C. O(n²)
D. O(log n)
→ 정답: ?

---

3. 주관식 문제
Q3.
DFS와 BFS는 그래프 탐색 알고리즘입니다.

DFS는 ( ) 구조를 사용하고,

BFS는 ( ) 구조를 사용합니다.
→ 괄호를 채우세요.

---

🌐 네트워크 전사 영역
4. OX 문제
Q4. TCP는 비연결형 프로토콜이며, 순서를 보장하지 않는다.
→ O / X

---

5. 객관식 문제
Q5. HTTP 상태 코드 중 리다이렉션을 나타내는 코드는?
A. 200
B. 301
C. 404
D. 500
→ 정답: ?

---

6. 주관식 문제
Q6.
3-way handshake 과정의 순서를 적으시오.
→ ( __ → __ → __ )

---

🛠 시스템 도적 영역 (설계)
7. OX 문제
Q7. 단일 책임 원칙(SRP)은 객체지향 설계에서 하나의 클래스가 여러 역할을 가져야 함을 의미한다.
→ O / X

---

8. 객관식 문제
Q8. 다음 중 REST API의 특징이 아닌 것은?
A. Stateless
B. 캐시 가능
C. 상태를 저장
D. 클라이언트-서버 구조
→ 정답: ?

---

9. 주관식 문제
Q9.
마이크로서비스 아키텍처에서, 각 서비스 간 데이터 일관성을 위해 사용하는 전략 중 하나로 분산 트랜잭션을 대신하여 최종적 일관성을 보장하는 방식은 무엇인가요?

---

🎁 보너스: 운영체제 문제
10. 객관식 문제
Q10. CPU 스케줄링 알고리즘 중 "가장 짧은 작업을 먼저 수행"하는 방식은?
A. Round Robin
B. SJF (Shortest Job First)
C. FCFS (First Come First Serve)
D. Priority Scheduling
→ 정답: ?

---

😎 점수 계산 예시
OX / 객관식: 1점

주관식: 2점

보너스 문제: 3점

총점: 14점 만점
 
---
<img width="1003" height="943" alt="스크린샷 2025-08-08 175521" src="https://github.com/user-attachments/assets/90ddfdc0-3f3b-4cee-acc8-e20405d6d126" />
<img width="1011" height="672" alt="스크린샷 2025-08-08 175529" src="https://github.com/user-attachments/assets/8c10e3ea-0f9e-4367-9464-606f0c1b8a79" />
문제가 공개된 뒤 차례대로 답을 입력했고, 각 문제에 대한 정답을 확인하며 나중에 점수를 부여했습니다.<br>
그렇게 저는 바로 마스터가 되었습니다!!

이후 바로 해설을 제공해주진 않아서, 제가 확인차 한 번 더 요청했고 그렇게 해설을 확인할 수 있었습니다.

---

🔮 알고리즘 마법사 영역 해설
Q1. 정렬된 배열에서 이진 탐색의 시간 복잡도는 O(n)이다.
❌ 정답: X (O(log n))

이진 탐색은 매 단계마다 검색 범위를 절반씩 줄이는 탐색 방법입니다.

따라서, 전체 탐색 횟수는 log₂(n)에 비례 → O(log n)
O(n)은 순차 탐색(Linear Search)의 시간 복잡도입니다.

---

Q2. 다음 중 시간 복잡도가 가장 느린 알고리즘은?
✅ 정답: C. O(n²)

O(log n): 이진 탐색, 매우 빠름
O(n): 한 번씩 순회
O(n log n): 병합 정렬(Merge Sort)
O(n²): 느린 알고리즘, 이중 for문 → 예: 버블 정렬, 삽입 정렬 등

---

Q3. DFS와 BFS는 어떤 구조를 사용하는가?
✅ 정답: DFS → 스택(또는 재귀), BFS → 큐

DFS (Depth First Search)
깊이 우선: 현재 경로를 따라 최대한 깊이 탐색
스택 사용, 재귀로도 구현 가능
BFS (Breadth First Search)
너비 우선: 가까운 노드부터 넓게 탐색
큐 사용, 선입선출 방식

---

🌐 네트워크 전사 영역 해설
Q4. TCP는 비연결형이며, 순서를 보장하지 않는다.
❌ 정답: X

TCP는 연결지향형 프로토콜입니다.
→ 3-way handshake를 통해 연결을 설정하고
→ 전송 순서를 보장하며, 손실 시 재전송합니다.

반면, UDP는 비연결형, 순서/정합성 보장 없음

---

Q5. HTTP 상태 코드 중 리다이렉션을 나타내는 코드는?
✅ 정답: B. 301

301: Moved Permanently → 영구 리다이렉션
200: 성공
404: Not Found
500: 서버 에러

참고로, 302, 307, 308도 임시 리다이렉션 코드입니다.

---

Q6. 3-way handshake 과정의 순서는?
✅ 정답: SYN → SYN+ACK → ACK

클라이언트 → 서버: SYN (접속 요청)
서버 → 클라이언트: SYN + ACK (응답 및 요청 수락)
클라이언트 → 서버: ACK (수락 응답)
→ 이로써 양방향 연결이 설정됨

---

🛠 시스템 도적 영역 해설
Q7. 단일 책임 원칙(SRP)은 하나의 클래스가 여러 책임을 져야 함을 의미한다.
❌ 정답: X

SRP (Single Responsibility Principle)
하나의 클래스는 오직 하나의 책임만 가져야 함
즉, 변경 이유는 단 하나뿐이어야 함
여러 책임이 섞이면 유지보수 시 리스크가 커짐

---

Q8. REST API의 특징이 아닌 것은?
✅ 정답: C. 상태를 저장

REST는 **Stateless(무상태성)**이 핵심
서버는 클라이언트의 이전 상태 정보를 저장하지 않음
클라이언트가 매 요청마다 필요한 모든 정보를 포함해야 함
나머지 보기 (A, B, D)는 REST의 진짜 특징입니다

---

Q9. 마이크로서비스에서 최종 일관성을 보장하는 방식은?
✅ 정답: SAGA 패턴

분산 시스템에서는 트랜잭션이 DB처럼 atomic하지 않음
SAGA는 각 서비스의 작업 단위를 서로 다른 보상 트랜잭션으로 연결
실패 시 이전 작업을 롤백하기 위한 보상 작업 실행

예: 항공권 예매 → 좌석 예약 → 결제 실패 → 좌석 예약 롤백

---

🎁 보너스 문제 (운영체제)
Q10. 가장 짧은 작업을 먼저 수행하는 CPU 스케줄링 알고리즘은?
✅ 정답: B. SJF (Shortest Job First)

SJF는 실행 시간이 가장 짧은 프로세스를 먼저 실행
평균 대기 시간을 최소화함 (이론상 가장 효율적)
단점: 실행 시간 예측이 어려움, 기아 현상 발생 가능
Round Robin: 타임 슬라이스 기반
FCFS: 순서대로 실행
Priority: 우선순위 기준 (낮은 작업이 밀릴 수 있음)

---

다음과 같이 문제에서 언급되었던 용어들의 설명이 정리된 해설을 확인할 수 있었습니다.<br>
문제의 유형들이 가볍게 지식을 꺼내보기 좋다고 생각했습니다.<br>
다음 릴레이 프로젝트를 만든다면, 이렇게 짧은 시간에 부담 없이 풀어볼 수 있는 문제를 제작해보는 것이 좋은 아이디어이지 않을까, 그렇게 여기고 있습니다!

</details>

---
